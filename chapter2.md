# 正式开始：它到底是什么？

从这部分开始我们尽可能地严谨起来。这样看起来可能像数学教材，所以我们会随时进行一些思考练习，帮助理解。当遇到这些思考练习时，我希望你可以停下来先好好想想。如果实在想不通，那么请再 **仔细** 读读之前的相关内容，相信你一定可以想通。当然如果遇到了困难，后续文中会有关于思考练习的相关回答。

首先，λ演算（Lambda Calculus）本质上是一个 **形式系统** ，即是说它由 **形式语言** 和 **推理规则（或转换规则）** 组成。通俗的讲，Church建立了一套语言，这套语言有一定的语法来形成自己的语句，并且这些合法的语句之间有一些转换关系，Church希望通过这套语言能更方便地描述研究某些关于函数本质的问题。举例来说，比如，经过几个世纪的努力，我们现在可以用阿拉伯数字（1234567890）、加减乘除（+-×÷）、小数点（.）、等号（=）等符号，加之加法结合律等一系列转换规则构建一套 **形式系统**，用来描述和研究关于数量的问题。同样的，λ演算也是这样一套系统，只不过它研究的是“函数定义、函数应用和递归”。

有了这样的定义，我们就更好地理解，λ演算实际上和我们已经烂熟于心的整数或小数四则运算一样，都是很抽象的。只不过我们已经熟悉了利用阿拉伯数字进行计算，并很好的映射到我们所感知的客观世界中。所以，在理解λ演算前，我们最好暂时忘掉心中其他的形式系统，尤其是包括从基础教育就开始接触的函数表示法，诸如 $$f(x)=x+2$$ ， $$\frac{g(h(y))}{F(x)}$$ 等。在严格的规则没有理解之前就使用类比来学习新的理论特别容易产生歧义理解。所以，本书会在把λ演算的基础公理介绍完毕后，再渐渐地向我们熟悉的知识结构延伸。


## 形式语言

组成λ演算的语言的最小单位是 **λ项（Lambda Term）**，或称为 **λ表达式（Lambda Expression）**，合法的λ项有且仅有以下三条规则归纳定义：

1. 每个变量是一个λ项
2. 如果 $$M$$ 是一个λ项，$$x$$ 是一个变量，那么$$(\lambda x.M)$$是一个λ项
3. 如果 $$M$$ 和 $$N$$ 都是λ项，那么$$(M N)$$是一个λ项

第2条规则中的λ项 $$(\lambda x.M)$$ 被称作一个 **λ抽象（Lambda Abstraction）**，其中的$$M$$部分被称作 **λ抽象体（The body of Lambda Abstraction）**，如果λ抽象体中含有变量$$x$$，那么该λ抽象可被称作“ $$\lambda$$ 绑定了 $$M$$ 中 $$x$$ ”。

第3条规则中的λ项 $$(M N)$$ 被称作一个 **函数作用（Application）**。

> 思考： $$(\lambda x.x+2)$$ 是否是合法的λ项？

让我们仔细想想，上面这个定义还是不够严谨。容易引起误会的地方可能是每个人对于 *变量* 的理解是不一样的。当然这里我们可以解释说变量即是一个符号，甚至可以举几个例子。但下面还是给出一个更加严谨的定义，只不过该定义还需要基于 **集合** 和  **上下文无关文法** 等的定义：

形式化地，我们从一个标识符（identifier）的 **可数无穷集合** 开始，比如$$\{a, b, c, ..., x, y, z, x_1, x_2, ...\}$$，则所有的λ项可以通过下述以 **BNF范式** 表达的 **上下文无关文法** 描述：

1. <表达式> ::= <标识符>
2. <表达式> ::= (λ<标识符>.<表达式>)
3. <表达式> ::= (<表达式> <表达式>)

我们无法像编程那样直接引入其他定义来定义新的概念，所以后面给出的这个更严谨但是基于更多概念的定义可以仅作为对比理解。不难看出，对于λ项定义中的变量，和我们所熟知的函数表达式中的变量概念没有出入，都是一种标识符。

所以，其他关于λ项的定义还可以从构成λ项的所有字符出发，来构建整个形式语言，这里不再作深入讨论。但容易看出，λ项的定义中，除了变量标识符外，只存在以下种常用字符：

1. $$\lambda$$和$$.$$
2. $$($$和$$)$$

以上两组中每对字符都是同时出现。

所以请注意！目前我们还没有定义到“四则运算”，故而 $$(\lambda x.x+2)$$ 并不是合法的λ项。

## 推理规则

形式语言构建出了整个世界，现在我们要让整个世界动起来。首当其冲地，我们需要引入一个符号 $$=$$，它用来表示λ项之间的一种 **等价关系**，与我们所熟知的一样，这种 **等价关系**，我们称之为“相等”

> **等价关系** 是一种特殊的 **关系**，而 **关系** 的定义来自于 **笛卡尔积** 和 **集合**。简单的讲，它是用来描述两个元素之间联系的概念，也是有且仅有以下三条规则归纳定义：
>
> 1. 自反性：每个元素都与自己具有等价关系
> 2. 对称性：若一个元素a与另一个元素b具有等价关系，那么元素b也与元素a具有等价关系
> 3. 传递性：若一个元素a与另一个元素b具有等价关系，元素b与一个元素c也具有等价关系，那么元素a与元素c具有等价关系
>
> 这里使用 **等价关系**，而不直接引入我们熟知的“相等”概念，是为了更严谨地从无到有建立λ演算的形式系统。

有了“相等”的概念，我们现在再引入一些简化（simplify）规则。简化包括非必需的左右括号 $$($$ 和 $$)$$ 和对形式语言做一些补充说明。
1. 最外层括号可去除（Outermost parentheses are dropped）：如果 $$M$$ 为一个独立的λ项，那么 $$(M) = M$$
2. λ抽象体最大化（The body of an abstraction extends as far right as possible）：如果 $$M$$ 为一个λ项，$$x$$ 为一个变量，那么 $$(\lambda x.(M)) = (\lambda x.M)$$
3. 函数应用左结合（Applications are assumed to be left-associative）：如果 $$M$$，$$N$$，$$P$$ 皆是一个λ项，那么 $$((M N) P) = (M N P)$$
4. 连续λ抽象可收缩（A sequence of abstractions is contracted）：如果 $$x$$, $$y$$, $$z$$ 皆是一个变量，$$M$$ 是一个λ项，那么 $$(\lambda x.(\lambda y.(\lambda z.M))) = (\lambda xyz.M)$$

最外层括号可去除即是说，在λ项严格定义中的左右括号是用来标明计算优先级的，但当这种说明到了最外层时显然变得没有意义，故可以去除。

λ抽象体最大化即是说，λ抽象的作用域在没有左右括号说明的情况下，是扩展到最右侧的。这种情况多数出现在λ抽象体本身是一个函数应用的情况，举例来说，$$x$$是一个变量，$$M$$ 和 $$N$$ 皆为一个λ项，那么 $$(\lambda x.M N)$$ 与 $$(\lambda x.(M N))$$ 等价，而不是 $$((\lambda x.M) N)$$ 。

函数应用左结合比较容易理解，与我们熟知的整数的结合律（Associative Property）相似。

> 思考： λ抽象是左结合还是右结合？

连续λ抽象可收缩更多地是一种简写形式。但请注意，这一条规则中的等价关系看起来比较复杂，里面其实少了一步简化过程。应用第二条简化规则（λ抽象体最大化）可以得到$$(\lambda x.(\lambda y.(\lambda z.M))) = (\lambda x.\lambda y.\lambda z.M)$$。由此可见，λ抽象是右结合的。

接下来，我们需要引入新的概念，来标记一个λ项中的变量是否被λ抽象绑定。在λ抽象的定义中，我们把 $$\lambda$$ 后的变量同时出现在抽象体中的情况称作该变量 *被绑定*，该变量也被称作 *绑定变量*，而λ抽象体中的所有其余变量被称作 *自由变量*。举例来说，$$\lambda y. x x y$$中，$$x$$为自由变量，$$y$$为绑定变量。还需要注意的是，变量只被最近（nearest）的λ抽象绑定，举例来说，$$\lambda x.y (\lambda x.z x)$$中，只有在括号中的变量$$x$$被称作被绑定。

一个λ项 $$M$$ 的全体自由变量可以组成一个集合，我们引入一个新符号，将这个集合记作$$FV(M)$$。该集合有且仅有以下三条规则归纳定义：

1. 如果 $$x$$ 是一个变量，那么 $$FV(x) = \{  x \}$$
2. 如果 $$x$$ 是一个变量，$$M$$ 是一个λ项，那么 $$FV(\lambda x.M) = FV(M) \setminus \{ x \}$$
3. 如果 $$M$$，$$N$$ 皆是一个λ项，那么 $$FV(M N) = FV(M) \cup FV(N)$$

同理地，我们还可以定绑定变量的集合，记作 $$BV(M)$$：

1. 如果 $$x$$ 是一个变量，那么 $$BV(x) = \phi$$
2. 如果 $$x$$ 是一个变量，$$M$$ 是一个λ项，那么 $$BV(\lambda x.M) = BV(M) \cup \{ x \}$$
3. 如果 $$M$$，$$N$$ 皆是一个λ项，那么 $$FV(M N) = FV(M) \cup FV(N)$$

我们将自由变量集合为空集的λ项称作 **组合子（Combinator）**
